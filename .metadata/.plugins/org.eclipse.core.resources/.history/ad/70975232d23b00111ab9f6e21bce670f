import java.util.HashMap;

import espest.OperadorGeral;
import espest.Transicao;


public class MecProcPDM<E> {

	private ModeloPDM<E> modelo;
	private double gamma;
	private double epsilon;
	private HashMap<E,Double> u;
	private HashMap<E,Double> uAnt;
	private double delta;
	

	public void planearPolitica(){}
	
	
	private void iterarUtilidade(){
		
		Transicao<E> trans;
		double us, usAnt, du;
		
		// Inicializar o modelo
		for(E s : modelo.s()){
			u.put(s, 0.0);				
		}
		do{
			// guardar modelo para nova iteração
			for(E s : modelo.s()){
				uAnt.put(s, u.get(s));
			}
			
			delta = 0;
			
			for(E s : modelo.s()){
				trans = maxTrans(s, uAnt);
				us = utilTrans(s, uAnt);
				usAnt=u.put(s, us);
				du=Math.abs(us-usAnt);
				if(du>delta)
					delta=du;
			}
			
		}while(delta > (epsilon*(1-gamma)/gamma));
		
	}
	//utilidade da transição
	private double utilTrans(Transicao<E> trans, HashMap<E, Double> u){
		
		// s linha
		E sn = trans.obterEstadoSuc();
		// utilidade de s linha
		double usn = u.get(sn);
		// a probabilidade de ir para s linha
		double t = modelo.t(trans);
		// a recompensa de ir para s linha
		double r = modelo.r(trans);

		return t*(r+gamma*usn);
	}
	
	private Transicao<E> maxTrans(E s, HashMap<E, Double> u){
		
		double uMax = Double.NEGATIVE_INFINITY;
		Transicao<E> transMax = null;
		
		for(OperadorGeral<E> oper : modelo.o(s))
			for(Transicao<E> trans : oper.aplicar(s)){
				
				double utrans = utilTrans(trans, u);
				if(utrans > uMax){
					uMax = utrans;
					transMax = trans;
				}
			}
		
		return transMax;
			
	}

	private void gerarPolitica(){
		
		Politica
	}
}
